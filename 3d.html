<!doctype html>
<html>
<head>
	<script src="jquery-1.6.1.js"></script>
	<script src="underscore.1.2.0.js"></script>
	<script src="backbone.0.5.3.js"></script>
	<script src="Three.js"></script>
	<script src="Tween.js"></script>
	<script>
	$(function(){
		var DEG2RAD = Math.PI / 180,
			img = document.createElement('img'),
			SPRITEWIDTH,
			SPRITEHEIGHT;
			
		img.onload = function(){
			document.body.appendChild(img);
			SPRITEWIDTH = img.clientWidth;
			SPRITEHEIGHT = img.clientHeight;
			document.body.removeChild(img);
			init();
		};
		img.src = 'chars.png';

		function init(){
			var chars = 'ABCDE'.split(''),
				canvas = document.createElement('canvas'),
				ctx = canvas.getContext("2d");
				
			canvas.width = SPRITEWIDTH;
			canvas.height = SPRITEHEIGHT;
			document.body.appendChild(canvas);
			ctx.drawImage(img, 0, 0);
							
			var x = 0,
				faces = {},
				faceSize = SPRITEHEIGHT / 2;
			
			// Collect the top and bottom segments of characters from our sprite
			chars.forEach(function(char, i){
				var top = ctx.getImageData(x, 0, faceSize, faceSize),
					bottom = ctx.getImageData(x, faceSize, faceSize, faceSize),
					upper = new THREE.DataTexture(new Uint8Array(top.data), faceSize, faceSize),
					lower = new THREE.DataTexture(new Uint8Array(bottom.data), faceSize, faceSize);
					
					upper.needsUpdate = lower.needsUpdate = true;
					
				faces[char] = {
					top: new THREE.MeshLambertMaterial({
						map: upper
					}),
					bottom: new THREE.MeshLambertMaterial({
						map: lower
					})
				};
				x += faceSize;
			});
			
			// Now flip the canvas and retrieve the back of each character flipper
			ctx.translate(SPRITEWIDTH, SPRITEHEIGHT);
			ctx.scale(-1, -1);
			ctx.drawImage(img, 0, 0);
			chars.forEach(function(char, i){
				x -= faceSize;
				var flip = ctx.getImageData(x, 0, faceSize, faceSize),
					back = new THREE.DataTexture(new Uint8Array(flip.data), faceSize, faceSize);
					
					back.needsUpdate = true;
				
				faces[char].back = new THREE.MeshLambertMaterial({
					map: back
				});
			});
			document.body.removeChild(canvas);
			canvas = null;
			
			var WIDTH = window.innerWidth,
				HEIGHT = window.innerHeight,
				VIEW_ANGLE = 45,
				ASPECT = (WIDTH / HEIGHT),
				NEAR = -2000,
				FAR = 1000,
				$container = $('#container'),
				renderer = new THREE.WebGLRenderer,
				camera = new THREE.OrthographicCamera(
					window.innerWidth / - 2,
					window.innerWidth / 2,
					window.innerHeight / 2,
					window.innerHeight / - 2,
					NEAR,
					FAR),
				scene = new THREE.Scene;
	
			// Start the renderer
			renderer.setSize(WIDTH, HEIGHT);
	
			$container.append(renderer.domElement);
	
			// Render our cube
			var FLAPWIDTH = 80, FLAPHEIGHT = 80, FLAPDEPTH = 2,
				pointLight = new THREE.PointLight(0xFFFFFF);
			
			pointLight.position.x = window.innerWidth / 2;
			pointLight.position.y = 0;
			pointLight.position.z = 1000;
			scene.add(pointLight);
		
			// Pull the camera back
			camera.position.x = window.innerWidth / 2 - FLAPWIDTH;
			camera.position.y = -window.innerHeight / 2 + (FLAPHEIGHT * 2);
			camera.position.z = 0;

			var flaps = [],
				addFlap = function(x, y){
					var wrapper = new THREE.Object3D(),
						flapWrapper = new THREE.Object3D(),
						top = new THREE.Mesh(
							new THREE.CubeGeometry(FLAPWIDTH, FLAPHEIGHT, FLAPDEPTH),
							faces.B.top),
						bottom = new THREE.Mesh(
							new THREE.CubeGeometry(FLAPWIDTH, FLAPHEIGHT, FLAPDEPTH),
							faces.A.bottom),
						flap = new THREE.Mesh(
							new THREE.CubeGeometry(FLAPWIDTH, FLAPHEIGHT, FLAPDEPTH),
							faces.B.back);
			
					flap.position.y = FLAPHEIGHT / 2;
					flapWrapper.position.y = FLAPHEIGHT / 2;
					top.position.y = FLAPHEIGHT;
					wrapper.position.x = x;
					wrapper.position.y = y;
					flapWrapper.add(flap);
					wrapper.add(flapWrapper);
					wrapper.add(top);
					wrapper.add(bottom);
					scene.add(wrapper);
				
					flaps.push(flapWrapper);
				};
	
			var render = function(){
				renderer.render(scene, camera);
			};
		
			var drawRow = function(y){
				var i = 0,
					x = 0;
				while(i < 14){
					addFlap(x, y);
					x += FLAPWIDTH + 16;
					i++;
				}
			};
		
			var i = 0,
				y = 0;
			while(i < 4){
				drawRow(y);
				y -= FLAPHEIGHT * 2 + 16;
				i++;
			}
		
			render();
			// Tween it
			TWEEN.start();
		
			var rotation = {
					x: 0
				},
				update = function(){
					flaps.forEach(function(flapWrapper){
						flapWrapper.rotation.x = rotation.x;
					});
					render();
				};
			
			var flip = new TWEEN.Tween(rotation).
				to({x: 180 * DEG2RAD}, 2000).
				onUpdate(update).
				onComplete(function(){
					rotation.x = 0;
				});
			
			flip.chain(flip);
			flip.start();
		};
	});
	</script>
	<style>
	*{
		margin:0;
		padding:0;
	}
	</style>
</head>
<body>
	<div id="container"></div>
</body>
</html>