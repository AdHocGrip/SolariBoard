<!doctype html>
<html>
<head>
	<script src="jquery-1.6.1.js"></script>
	<script src="underscore.1.2.0.js"></script>
	<script src="backbone.0.5.3.js"></script>
	<script src="Three.js"></script>
	<script src="stats.js"></script>
	<script src="Tween.js"></script>
	<script>
	$(function(){
		var DEG2RAD = Math.PI / 180,
			img = document.createElement('img'),
			stats,
			SPRITEWIDTH,
			SPRITEHEIGHT;
			
		img.onload = function(){
			document.body.appendChild(img);
			SPRITEWIDTH = img.clientWidth;
			SPRITEHEIGHT = img.clientHeight;
			document.body.removeChild(img);
			init();
		};
		img.src = 'chars.jpg';

		function init(){
			var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ123456789-. '.split(''),
				canvas = document.createElement('canvas'),
				ctx = canvas.getContext("2d");
				
			canvas.width = SPRITEWIDTH;
			canvas.height = SPRITEHEIGHT;
			document.body.appendChild(canvas);
			ctx.drawImage(img, 0, 0);
							
			var faces = {},
				faceSize = SPRITEHEIGHT / 2,
				x = 0;
			
			// Collect the top and bottom segments of characters from our sprite
			chars.forEach(function(char, i){
				var top = ctx.getImageData(x, 0, faceSize, faceSize),
					bottom = ctx.getImageData((x === 0) ? faceSize * (chars.length - 1) : x - faceSize, faceSize, faceSize, faceSize),
					upper = new THREE.DataTexture(new Uint8Array(top.data), faceSize, faceSize),
					lower = new THREE.DataTexture(new Uint8Array(bottom.data), faceSize, faceSize);
					
					upper.needsUpdate = lower.needsUpdate = true;
					
				faces[char] = {
					topMaterial: new THREE.MeshLambertMaterial({
						map: upper
					}),
					bottomMaterial: new THREE.MeshLambertMaterial({
						map: lower
					})
				};
				
				x += faceSize;
			});
			
			// Now flip the canvas and retrieve the back of each character flipper
			ctx.translate(SPRITEWIDTH, SPRITEHEIGHT);
			ctx.scale(-1, -1);
			ctx.drawImage(img, 0, 0);
			chars.forEach(function(char, i){
				x -= faceSize;
				var flip = ctx.getImageData(x, 0, faceSize, faceSize),
					back = new THREE.DataTexture(new Uint8Array(flip.data), faceSize, faceSize);
					
					back.needsUpdate = true;
				
				var prev = chars[i-1] ? chars[i-1] : chars[chars.length-1];
				
				faces[char].flipperMaterials = [
					null,
					null,
					null,
					null,
					faces[prev].topMaterial,
					new THREE.MeshLambertMaterial({
						map: back
					})
				];
			});
			document.body.removeChild(canvas);
			canvas = null;
			
			var WIDTH = window.innerWidth,
				HEIGHT = window.innerHeight,
				VIEW_ANGLE = 45,
				ASPECT = (WIDTH / HEIGHT),
				NEAR = -2000,
				FAR = 1000,
				$container = $('#container'),
				renderer = new THREE.WebGLRenderer,
				camera = new THREE.OrthographicCamera(
					window.innerWidth / - 2,
					window.innerWidth / 2,
					window.innerHeight / 2,
					window.innerHeight / - 2,
					NEAR,
					FAR),
				scene = new THREE.Scene;
			
			// Start the renderer
			renderer.setSize(WIDTH, HEIGHT);
			renderer.setClearColorHex(0x111111, 1);
			
			$container.append(renderer.domElement);
	
			// Render our cube
			var FLAPWIDTH = 80, FLAPHEIGHT = 80, FLAPDEPTH = 0,
				pointLight = new THREE.PointLight(0xFFFFFF);
			
			pointLight.position.x = window.innerWidth / 2;
			pointLight.position.y = 0;
			pointLight.position.z = 1000;
			scene.add(pointLight);
		
			// Pull the camera back
			camera.position.x = window.innerWidth / 2 - FLAPWIDTH;
			camera.position.y = -window.innerHeight / 2 + (FLAPHEIGHT * 2);
			camera.position.z = 0;

			var flaps = [],
				addFlap = function(x, y){
					var sets = [];
					
					chars.forEach(function(c){
						var wrapper = new THREE.Object3D,
							flapWrapper = new THREE.Object3D,
							top = new THREE.Mesh(
								new THREE.PlaneGeometry(FLAPWIDTH, FLAPHEIGHT),
								[faces[c].topMaterial]),
							bottom = new THREE.Mesh(
								new THREE.PlaneGeometry(FLAPWIDTH, FLAPHEIGHT),
								[faces[c].bottomMaterial]),
							flap = new THREE.Mesh(
								new THREE.CubeGeometry(FLAPWIDTH, FLAPHEIGHT, FLAPDEPTH, 1, 1, 1, faces[c].flipperMaterials),
								new THREE.MeshFaceMaterial());
							
						flap.position.y = FLAPHEIGHT / 2;
						flapWrapper.position.y = FLAPHEIGHT / 2;
						flapWrapper.position.z = 2;
						top.position.y = FLAPHEIGHT;
						top.position.z = 1;
						bottom.position.z = 1;
						wrapper.position.x = x;
						wrapper.position.y = y;
						
						wrapper._flapWrapper = flapWrapper;
						wrapper._flap = flap;
						wrapper.add(top);
						wrapper.add(bottom);
						
						flapWrapper.add(flap);
						wrapper.add(flapWrapper);
						
						sets[c] = wrapper;
					});
					var active = sets[chars[0]];

					return {
						i: 0,
						max: chars.length - 1,
						active: active,
						sets: sets
					};
				};
	
			var render = function(){
				renderer.render(scene, camera);
			};
		
			var drawRow = function(y){
				var i = 0,
					x = 0;
				while(i < 12){
					flaps.push(addFlap(x, y));
					x += FLAPWIDTH + 8;
					i++;
				}
			};
		
			var i = 0,
				y = 0;
			while(i < 4){
				drawRow(y);
				y -= FLAPHEIGHT * 2 + 16;
				i++;
			}
			
			var stats = new Stats();
			stats.domElement.style.position = 'absolute';
			stats.domElement.style.top = '0px';
			document.body.appendChild(stats.domElement);
			
			render();
			// Tween it
			TWEEN.start();
		
			var rotation = {
					x: 0
				},
				MAX_X = 180 * DEG2RAD,
				flapLoop = function(flap){
					flap.active._flapWrapper.rotation.x = rotation.x;
				},
				completeLoop = function(flap){
					scene.remove(flap.active);
					flap.i = flap.i >= flap.max ? 0 : flap.i + 1;
					flap.active = flap.sets[chars[flap.i]];
					scene.add(flap.active);
				},
				update = function(){
					flaps.forEach(flapLoop);
					render();
					stats.update();
				};
			
			var flip = new TWEEN.Tween(rotation).
				to({x: MAX_X}, 200).
				onUpdate(update).
				onComplete(function(){
					rotation.x = 0;
					flaps.forEach(completeLoop);
				});
			
			flip.chain(flip);
			flip.start();
		};
	});
	</script>
	<style>
	*{
		margin:0;
		padding:0;
	}
	body{
		background:#000;
	}
	</style>
</head>
<body>
	<div id="container"></div>
</body>
</html>